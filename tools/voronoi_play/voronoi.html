<!doctype html>
<meta charset="utf-8">
<title>Keyboard movment</title>
<body>
<script src="pixi.min.js"></script>
<script>
//Constants
window.SCREEN_HEIGHT = Math.min(window.innerHeight - 20, window.innerWidth - 20);
window.SCREEN_WIDTH = Math.min(window.innerHeight - 20, window.innerWidth - 20);
window.GRID_HEIGHT = 64;
window.GRID_WIDTH = 64;
//Aliases
let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.loader,
    resources = PIXI.loader.resources,
    TextureCache = PIXI.utils.TextureCache,
    Graphics = PIXI.Graphics;
    InteractionManager = PIXI.interaction.InteractionManager;
//Create a Pixi Application
let app = new Application({ 
    width: window.SCREEN_WIDTH, 
    height: window.SCREEN_HEIGHT,                       
    antialiasing: true, 
    transparent: false, 
    resolution: 1
  }
);
var manager = new InteractionManager(app.renderer);
//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);
loader
  .load(setup);
//Define any variables that are used in more than one function
var state, graphics, active_tile;
var grid, need_recalculate, color_map, seed_map;
var xOffset, yOffset;
var pressed;

function setup() {
    // Create graphics
    graphics = new Graphics();
    app.stage.addChild(graphics);

    // Handlers
    app.stage.interactive = true;
    app.stage.on('click', function(event) {
        active_tile = { x: Math.floor(window.GRID_WIDTH * manager.mouse.global.x / window.SCREEN_WIDTH) - Math.round(xOffset),
            y: Math.floor(window.GRID_HEIGHT * manager.mouse.global.y / window.SCREEN_HEIGHT) - Math.round(yOffset) };
        if(active_tile.x < 0) active_tile.x += window.GRID_WIDTH;
        if(active_tile.y < 0) active_tile.y += window.GRID_HEIGHT;
    });
    document.onkeydown=function(e) {
        if(active_tile != null && e.keyCode >= 48 && e.keyCode <= 57) {
            grid[active_tile.y][active_tile.x] = e.keyCode - 48;
            active_tile = null;
            need_recalculate = true;
        }
        else if(e.keyCode == 79) { //o
            xOffset = 0;
            yOffset = 0;
        }
        pressed[e.keyCode.toString()] = true;
    }
    document.onkeyup=function(e) {
        pressed[e.keyCode.toString()] = false;
    }

    grid = [];
    for(let y = 0; y < window.GRID_HEIGHT; y++) {
        grid.push(new Array(window.GRID_WIDTH).fill(0));
    }
    active_tile = null;
    need_recalculate = true;
    pressed = {}
    xOffset = 0;
    yOffset = 0;

    //Start the game loop 
    render();
}

function recalculate_colormap() {
    color_map = [];
    for(let y = 0; y < window.GRID_HEIGHT; y++) color_map.push(new Array(window.GRID_WIDTH).fill(0));

    seed_map = [];
    for(let y = 0; y < window.GRID_HEIGHT; y++) seed_map.push(new Array(window.GRID_WIDTH).fill(false));

    function colorMap(val) {
        return [
            '0x000000',
            '0x9010B9',
            '0x005DD0',
            '0xF577F2',
            '0x23D1DE',
            '0xB11243',
            '0xFF704B',
            '0x00B553',
            '0xF8EC31',
            '0xFFFFFF'][val];
    }

    function locationEncode(x, y) {
        return x.toString() + "_" + y.toString();
    }
    function locationDecode(str) {
        split = str.split("_");
        return { x: parseInt(split[0]), y: parseInt(split[1]) };
    }
    function getLocation(l, dir) {
        let loc = Object.assign({}, l);
        if(dir === "n") {
            loc.y--;
            if(loc.y === -1) loc.y += window.GRID_HEIGHT;
        }
        else if(dir === "e") {
            loc.x++;
            if(loc.x === window.GRID_WIDTH) loc.x -= window.GRID_WIDTH;
        }
        else if(dir === "s") {
            loc.y++;
            if(loc.y === window.GRID_HEIGHT) loc.y -= window.GRID_HEIGHT;
        }
        else if(dir === "w") {
            loc.x--;
            if(loc.x === -1) loc.x += window.GRID_WIDTH;
        }
        return loc;
    }

    front = {};
    for(let y = 0; y < window.GRID_HEIGHT; y++) {
        for(let x = 0; x < window.GRID_WIDTH; x++) {
            if(grid[y][x] != 0) {
                front[locationEncode(x, y)] = new Set([colorMap(grid[y][x])]);
                seed_map[y][x] = true;
            }
        }
    }

    while(Object.keys(front).length > 0) {
        for(var key in front) {
            let loc = locationDecode(key);
            color_map[loc.y][loc.x] = front[key];
        }
        front2 = {}
        for(var key in front) {
            let loc = locationDecode(key);
            let directions = ["n", "e", "s", "w"];
            for(let d = 0; d < directions.length; d++) {
                let loc2 = getLocation(loc, directions[d]);
                if(color_map[loc2.y][loc2.x] === 0) {
                    const loc2encode = locationEncode(loc2.x, loc2.y);
                    if(!(loc2encode in front2)) front2[loc2encode] = new Set();
                    for(let color of front[key]) front2[loc2encode].add(color);
                }
            }
        }
        front = front2;
    }

    for(let y = 0; y < window.GRID_HEIGHT; y++) {
        for(let x = 0; x < window.GRID_WIDTH; x++) {
            if(color_map[y][x].size == 1) for(let color of color_map[y][x]) color_map[y][x] = color;
            else if(color_map[y][x].size == 0) color_map[y][x] = '0x000000';
            else color_map[y][x] = '0x606060';
        }
    }
}

function render() {
    if(need_recalculate) {
        recalculate_colormap();
        need_recalculate = false;
    }

    graphics.clear();
    const CELL_WIDTH = window.SCREEN_WIDTH / window.GRID_WIDTH, CELL_HEIGHT = window.SCREEN_HEIGHT / window.GRID_HEIGHT;
    let ty = Math.round(yOffset);
    for(let y = 0; y < window.GRID_HEIGHT; y++) {
        let tx = Math.round(xOffset);
        for(let x = 0; x < window.GRID_WIDTH; x++) {
            graphics.beginFill(color_map[y][x], seed_map[y][x] ? 1 : 0.25);
            graphics.drawRect(tx * CELL_WIDTH, ty * CELL_HEIGHT, CELL_WIDTH, CELL_HEIGHT)
            graphics.endFill();
            tx++;
            if(tx == window.GRID_WIDTH) tx = 0;
        }
        ty++;
        if(ty == window.GRID_HEIGHT) ty = 0;
    }

    app.render();

    // If moving two directions at once, divide by sqrt(2) so speed feels constant.
    const BASE_SCROLL_SPEED = 0.03;
    const SCROLL_SPEED = ((pressed['87']^pressed['83']) && (pressed['68']^pressed['65'])) ? BASE_SCROLL_SPEED / Math.sqrt(2) : BASE_SCROLL_SPEED;
    if(pressed['87']) yOffset += SCROLL_SPEED * GRID_HEIGHT;
    if(pressed['68']) xOffset -= SCROLL_SPEED * GRID_WIDTH;
    if(pressed['83']) yOffset -= SCROLL_SPEED * GRID_HEIGHT;
    if(pressed['65']) xOffset += SCROLL_SPEED * GRID_WIDTH;
    if(Math.round(xOffset) >= GRID_WIDTH) xOffset -= GRID_WIDTH;
    else if(Math.round(xOffset) < 0) xOffset += GRID_WIDTH;
    if(Math.round(yOffset) >= GRID_HEIGHT) yOffset -= GRID_HEIGHT;
    else if(Math.round(yOffset) < 0) yOffset += GRID_HEIGHT;

    setTimeout(function() {
        requestAnimationFrame(render);
    }, 1000 / 60.0);
}

</script>
</body>