#include <cstdlib>
#include <fstream>
#include <iostream>

#include "Config.hpp"
#include "Constants.hpp"
#include "Generator.hpp"
#include "Halite.hpp"
#include "Logging.hpp"
#include "Replay.hpp"
#include "Snapshot.hpp"
#include "SnapshotError.hpp"
#include "Statistics.hpp"
#include "Units.hpp"

#include "version.hpp"

#include "nlohmann/json.hpp"
#include "tclap/CmdLine.h"

/** The platform-specific path separator. */
#ifdef _WIN32
constexpr auto SEPARATOR = '\\';
#else
constexpr auto SEPARATOR = '/';
#endif

constexpr auto JSON_INDENT_LEVEL = 4;

int main(int argc, char *argv[]) {
    auto &constants = hlt::Constants::get_mut();
    hlt::Config config{};

    using namespace TCLAP;
    CmdLine cmd("Halite Game Environment", ' ', HALITE_VERSION);
    SwitchArg timeout_switch("", "no-timeout", "Causes game environment to ignore bot timeouts.", cmd, false);
    SwitchArg no_replay_switch("", "no-replay", "Turns off the replay generation.", cmd, false);
    SwitchArg print_constants_switch("", "print-constants", "Print out the default constants and exit.", cmd, false);
    SwitchArg no_compression_switch("", "no-compression", "Disables compression for output files.", cmd, false);
    SwitchArg json_results_switch("", "results-as-json", "Prints game results as JSON at end.", cmd, false);
    ValueArg<unsigned long> players_arg("n", "players", "Create a map that will accommodate n players.", false, 1,
                                        "positive integer", cmd);
    ValueArg<hlt::dimension_type> width_arg("", "width", "The width of the map.", false,
                                                 constants.DEFAULT_MAP_WIDTH,
                                                 "positive integer", cmd);
    ValueArg<hlt::dimension_type> height_arg("", "height", "The height of the map.", false,
                                                  constants.DEFAULT_MAP_HEIGHT,
                                                  "positive integer", cmd);
    ValueArg<unsigned int> seed_arg("s", "seed", "The seed for the map generator.", false, 0, "positive integer", cmd);
    ValueArg<unsigned long> turn_limit_arg("", "turn-limit", "The maximum number of turns to play.",
                                           false, 0, "positive integer", cmd);
    ValueArg<std::string> replay_arg("i", "replay-directory", "The path to directory for replay output.", false, ".",
                                     "path to directory", cmd);
    ValueArg<std::string> constants_arg("c", "constants-file", "JSON file containing runtime constants to use.", false,
                                        "", "path to file", cmd);
    ValueArg<std::string> snapshot_arg("", "from-snapshot", "A snapshot of the game state.", false,
                                       "",
                                       "snapshot generated by visualizer", cmd);
    ValueArg<std::string> map_type_arg("m", "map-type", "The map type.", false, "fractal",
                                       "[basic | blur_tile | fractal]", cmd);
    MultiArg<std::string> override_args("o", "override-names", "Overrides player-sent names.", false, "name strings",
                                        cmd);
    MultiSwitchArg verbosity_arg("v", "verbosity", "Increase the logging verbosity level.", cmd);
    UnlabeledMultiArg<std::string> command_args("bot-commands", "Start commands for bots.", true, "path strings", cmd);

    cmd.parse(argc, argv);

    // Update the game constants
    if (constants_arg.isSet()) {
        std::ifstream constants_file(constants_arg.getValue());
        nlohmann::json constants_json;
        constants_file >> constants_json;
        from_json(constants_json, constants);
    }

    // If requested, print constants and exit
    if (print_constants_switch.getValue()) {
        std::cout << nlohmann::json(constants).dump() << std::endl;
        return 0;
    }

    if (turn_limit_arg.isSet()) {
        constants.MAX_TURNS = turn_limit_arg.getValue();
    }

    // TODO: set game ID

    // Set the random seed
    config.seed = static_cast<unsigned int>(time(nullptr));
    std::srand(config.seed); // For all non-seeded randomness
    if (seed_arg.getValue() != 0) {
        config.seed = seed_arg.getValue();
    }

    // Get the map parameters
    auto map_width = width_arg.getValue();
    auto map_height = height_arg.getValue();
    auto n_players = players_arg.getValue();

    auto verbosity = verbosity_arg.getValue();
    verbosity++; // One more level than specified verbosity
    verbosity = verbosity > Logging::NUM_LEVELS ? 0 : Logging::NUM_LEVELS - verbosity;
    Logging::set_level(static_cast<Logging::Level>(verbosity));

    // Read the player bot commands
    auto bot_commands = command_args.getValue();
    if (bot_commands.size() > constants.MAX_PLAYERS) {
        std::cerr << "Error: too many players (max is " << constants.MAX_PLAYERS << ")" << std::endl;
        return 1;
    } else if (bot_commands.size() > n_players) {
        n_players = bot_commands.size();
        if (players_arg.isSet()) {
            std::cerr << "Warning: overriding the specified number of players." << std::endl;
        }
    }

    hlt::mapgen::MapType type;
    std::istringstream type_stream(map_type_arg.getValue());
    type_stream >> type;
    hlt::mapgen::MapParameters map_parameters{type, config.seed, map_width, map_height, n_players};

    hlt::Snapshot snapshot;
    if (!snapshot_arg.getValue().empty()) {
        try {
            snapshot = hlt::Snapshot::from_str(snapshot_arg.getValue());
        }
        catch (const SnapshotError& err) {
            std::cerr << err.what() << std::endl;
            return 1;
        }
        map_parameters = snapshot.map_param;
        config.seed = map_parameters.seed;
    }

    net::NetworkingConfig networking_config{};
    networking_config.ignore_timeout = timeout_switch.getValue();

    hlt::Map map(map_parameters.width, map_parameters.height);
    hlt::mapgen::Generator::generate(map, map_parameters);

    std::string replay_directory = replay_arg.getValue();
    if (replay_directory.back() != SEPARATOR) replay_directory.push_back(SEPARATOR);

    hlt::GameStatistics game_statistics;
    hlt::Replay replay{game_statistics, map_parameters.num_players, map_parameters.seed, map};

    hlt::Halite game(config, map, networking_config, game_statistics, replay);
    game.load_snapshot(snapshot);
    game.run_game(bot_commands);

    const auto& overrides = override_args.getValue();
    auto idx = 0;
    for (const auto& name : overrides) {
        if (idx < static_cast<int>(replay.players.size())) {
            replay.players.at(hlt::Player::id_type{idx}).name = name;
        }
        idx++;
    }

    // Output replay file for visualizer
    if (!no_replay_switch.getValue()) {
        // Output gamefile. First try the replays folder; if that fails, just use the straight filename.
        std::stringstream filename_buf;
        // While compilers like G++4.8 report C++11 compatibility, they do not
        // support std::put_time, so we have to use strftime instead.
        auto time = std::time(nullptr);
        auto localtime = std::localtime(&time);
        static constexpr size_t MAX_DATE_STRING_LENGTH = 25;
        char time_string[MAX_DATE_STRING_LENGTH];
        std::strftime(time_string, MAX_DATE_STRING_LENGTH, "%Y%m%d-%H%M%S%z", localtime);
        filename_buf << "replay-" << std::string(time_string);
        filename_buf << "-" << replay.map_generator_seed;
        filename_buf << "-" << map.width;
        filename_buf << "-" << map.height << ".hlt";
        auto filename = filename_buf.str();
        std::string output_filename = replay_directory + "Replays/" + filename;
        bool enable_compression = !no_compression_switch.getValue();
        try {
            replay.output(output_filename, enable_compression);
        }
        catch (std::runtime_error& e) {
            output_filename = replay_directory + filename;
            replay.output(output_filename, enable_compression);
        }
        std::stringstream replay_message;
        replay_message << "Map seed was " << replay.map_generator_seed << std::endl
                       << "Opening a file at " << output_filename << std::endl;

        // JSON results info, used by backend
        nlohmann::json results;
        results["error_logs"] = nlohmann::json::object();

        for (const auto &[player_id, _] : replay.players) {
            const auto& player = game.get_player(player_id);
            if (player.crashed) {
                std::stringstream logname_buf;
                logname_buf << "errorlog-" << std::string(time_string)
                            << "-" << replay.map_generator_seed
                            << "-" << map_width
                            << "-" << map_height
                            << "-" << player_id
                            << ".log";
                const auto log_filename = logname_buf.str();
                auto log_filepath = replay_directory + "Replays/" + log_filename;

                std::ofstream log_file;
                log_file.open(log_filepath, std::ios_base::out);
                if (!log_file.is_open()) {
                    log_filepath = replay_directory + log_filename;
                    log_file.open(log_filepath, std::ios_base::out);
                }

                results["error_logs"][to_string(player_id)] = log_filepath;

                log_file.write(player.error_log.c_str(), player.error_log.size());

                replay_message << "Player " << player_id << " crashed. "
                               << "Writing a log at " << log_filepath << std::endl;
            }
        }

        Logging::log(replay_message.str());

        if (json_results_switch.getValue()) {
            results["replay"] = output_filename;
            results["map_width"] = map_width;
            results["map_height"] = map_height;
            results["map_seed"] = config.seed;
            // TODO: put the actual generator here
            results["map_generator"] = "default";
            results["final_snapshot"] = game.to_snapshot(map_parameters);
            results["stats"] = nlohmann::json::object();
            for (const auto& stats : replay.game_statistics.player_statistics) {
                results["stats"][to_string(stats.player_id)] = { { "rank", stats.rank } };
            }
            std::cout << results.dump(JSON_INDENT_LEVEL) << std::endl;
        }
    }

    return 0;
}
